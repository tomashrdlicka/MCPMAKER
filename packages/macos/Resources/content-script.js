// ============================================================
// MCPMAKER Content Script (CDP Injection Version)
// DOM event capture, page snapshots, and action execution
// Designed for injection via Runtime.evaluate, not as a Chrome extension
// ============================================================

(function () {
  // Guard against double-injection
  if (window.__mcpmaker_injected) return;
  window.__mcpmaker_injected = true;

  // --- Public API ---
  // Events accumulate here instead of being sent via chrome.runtime.sendMessage
  window.__mcpmaker_events = [];

  // Recording state - starts automatically on injection
  window.__mcpmaker_recording = true;

  // --- Internal State ---
  var mutationObserver = null;
  var recordingIndicator = null;

  // ============================================================
  // CSS SELECTOR GENERATOR
  // ============================================================

  // Builds a robust, unique CSS selector for a given element.
  // 5-strategy approach:
  //   1. ID-based selector
  //   2. Data attributes (data-testid, data-cy, data-test, data-id)
  //   3. Aria-label + role
  //   4. Name attribute for form elements
  //   5. Path from ancestors
  function generateSelector(el) {
    // Strategy 1: ID
    if (el.id && !looksAutogenerated(el.id)) {
      var idSel = '#' + CSS.escape(el.id);
      if (isUnique(idSel)) return idSel;
    }

    // Strategy 2: Data attributes
    var dataAttrs = ['data-testid', 'data-cy', 'data-test', 'data-id'];
    for (var i = 0; i < dataAttrs.length; i++) {
      var val = el.getAttribute(dataAttrs[i]);
      if (val) {
        var sel = '[' + dataAttrs[i] + '="' + CSS.escape(val) + '"]';
        if (isUnique(sel)) return sel;
      }
    }

    // Strategy 3: Aria-label + role
    var ariaLabel = el.getAttribute('aria-label');
    var role = el.getAttribute('role');
    if (ariaLabel) {
      var sel2 = role
        ? '[role="' + CSS.escape(role) + '"][aria-label="' + CSS.escape(ariaLabel) + '"]'
        : '[aria-label="' + CSS.escape(ariaLabel) + '"]';
      if (isUnique(sel2)) return sel2;
    }

    // Strategy 4: Name attribute for form elements
    var name = el.getAttribute('name');
    if (name) {
      var tagName = el.tagName.toLowerCase();
      var sel3 = tagName + '[name="' + CSS.escape(name) + '"]';
      if (isUnique(sel3)) return sel3;
    }

    // Strategy 5: Build path from ancestors
    return buildPathSelector(el);
  }

  function looksAutogenerated(id) {
    // IDs that look like random hashes or framework-generated
    if (/^[a-f0-9]{8,}$/i.test(id)) return true;
    if (/^:r[0-9a-z]+:$/.test(id)) return true; // React auto IDs
    if (/^(ember|react|vue|ng|svelte)[_-]?\d+/i.test(id)) return true;
    if (id.length > 40) return true;
    return false;
  }

  function isUnique(selector) {
    try {
      return document.querySelectorAll(selector).length === 1;
    } catch (e) {
      return false;
    }
  }

  function buildPathSelector(el) {
    var parts = [];
    var current = el;

    while (current && current !== document.documentElement) {
      var part = current.tagName.toLowerCase();

      // Add ID if available and not auto-generated
      if (current.id && !looksAutogenerated(current.id)) {
        parts.unshift('#' + CSS.escape(current.id));
        break; // ID is a stable anchor
      }

      // Add class names (filter out dynamic/utility classes)
      var classes = getStableClasses(current);
      if (classes.length > 0) {
        part += '.' + classes.map(function (c) { return CSS.escape(c); }).join('.');
      }

      // Add nth-of-type if still not unique among siblings
      var parentEl = current.parentElement;
      if (parentEl) {
        var currentTag = current.tagName;
        var siblings = Array.from(parentEl.children).filter(function (s) {
          return s.tagName === currentTag;
        });
        if (siblings.length > 1) {
          var index = siblings.indexOf(current) + 1;
          part += ':nth-of-type(' + index + ')';
        }
      }

      parts.unshift(part);
      current = current.parentElement;

      // Stop if we have enough specificity (max depth 5)
      if (parts.length >= 5) break;
    }

    var selector = parts.join(' > ');

    // Verify the selector works
    try {
      if (document.querySelector(selector) === el) {
        return selector;
      }
    } catch (e) {
      // Fall through to full path
    }

    // Fallback: full path with nth-child from body
    return buildFullPathSelector(el);
  }

  function buildFullPathSelector(el) {
    var parts = [];
    var current = el;

    while (current && current !== document.body && current !== document.documentElement) {
      var parentEl = current.parentElement;
      if (!parentEl) break;

      var index = Array.from(parentEl.children).indexOf(current) + 1;
      parts.unshift(current.tagName.toLowerCase() + ':nth-child(' + index + ')');
      current = parentEl;
    }

    return 'body > ' + parts.join(' > ');
  }

  function getStableClasses(el) {
    var allClasses = Array.from(el.classList);
    return allClasses.filter(function (cls) {
      // Filter out dynamic classes
      if (/^[a-z]{1,3}[A-Z]/.test(cls)) return false; // camelCase modules
      if (/^css-[a-z0-9]+$/i.test(cls)) return false; // CSS-in-JS
      if (/^_[a-zA-Z0-9]{5,}$/.test(cls)) return false; // Hashed
      if (/^sc-[a-zA-Z]/.test(cls)) return false; // styled-components
      if (/^[a-f0-9]{6,}$/i.test(cls)) return false; // Hash-like
      if (cls.includes('__') && cls.includes('--')) return true; // BEM is stable
      return true;
    }).slice(0, 3); // Max 3 classes for readability
  }

  // ============================================================
  // ELEMENT CONTEXT EXTRACTION
  // ============================================================

  function getElementContext(el) {
    var parts = [];
    var tagName = el.tagName.toLowerCase();
    parts.push('<' + tagName + '>');

    // Surrounding label text
    var labels = getAssociatedLabels(el);
    if (labels.length > 0) {
      parts.push('labels: ' + labels.join(', '));
    }

    // Aria label
    var ariaLabel = el.getAttribute('aria-label');
    if (ariaLabel) {
      parts.push('aria-label: "' + ariaLabel + '"');
    }

    // Placeholder
    var placeholder = el.getAttribute('placeholder');
    if (placeholder) {
      parts.push('placeholder: "' + placeholder + '"');
    }

    // Button/link text
    var text = el.innerText ? el.innerText.trim() : '';
    if (text && text.length < 100) {
      parts.push('text: "' + text.slice(0, 80) + '"');
    }

    // Title attribute
    var title = el.getAttribute('title');
    if (title) {
      parts.push('title: "' + title + '"');
    }

    return parts.join(' | ');
  }

  function getAssociatedLabels(el) {
    var labels = [];

    // Check for <label for="id"> association
    if (el.id) {
      try {
        var labelEl = document.querySelector('label[for="' + CSS.escape(el.id) + '"]');
        if (labelEl && labelEl.textContent) {
          labels.push(labelEl.textContent.trim());
        }
      } catch (e) {
        // Invalid selector
      }
    }

    // Check for parent <label>
    var parentLabel = el.closest('label');
    if (parentLabel) {
      var text = parentLabel.textContent ? parentLabel.textContent.trim() : '';
      if (text) labels.push(text);
    }

    // Check for aria-labelledby
    var labelledBy = el.getAttribute('aria-labelledby');
    if (labelledBy) {
      var ids = labelledBy.split(/\s+/);
      for (var i = 0; i < ids.length; i++) {
        var labelEl2 = document.getElementById(ids[i]);
        if (labelEl2 && labelEl2.textContent) {
          labels.push(labelEl2.textContent.trim());
        }
      }
    }

    return labels.filter(Boolean);
  }

  function getAttributes(el) {
    var attrs = {};
    var interestingAttrs = [
      'type', 'name', 'role', 'aria-label', 'aria-expanded',
      'aria-selected', 'aria-checked', 'href', 'src', 'action',
      'method', 'placeholder', 'data-testid', 'data-cy'
    ];
    for (var i = 0; i < interestingAttrs.length; i++) {
      var val = el.getAttribute(interestingAttrs[i]);
      if (val !== null) {
        attrs[interestingAttrs[i]] = val;
      }
    }
    return attrs;
  }

  // ============================================================
  // EVENT CAPTURE
  // ============================================================

  function captureEvent(type, target, value) {
    if (!window.__mcpmaker_recording) return;

    var isSensitive = isPasswordField(target);

    var domEvent = {
      timestamp: Date.now(),
      type: type,
      selector: generateSelector(target),
      elementContext: getElementContext(target),
      tagName: target.tagName.toLowerCase(),
      attributes: getAttributes(target),
      ariaLabel: target.getAttribute('aria-label') || undefined,
      innerText: target.innerText ? target.innerText.trim().slice(0, 200) : undefined,
      formLabels: getAssociatedLabels(target),
      pageTitle: document.title,
      pageUrl: window.location.href
    };

    if (value !== undefined) {
      domEvent.value = isSensitive ? '***SENSITIVE***' : value;
    }

    if (isSensitive) {
      domEvent.inputType = 'password';
    } else if (target instanceof HTMLInputElement) {
      domEvent.inputType = target.type;
    }

    window.__mcpmaker_events.push(domEvent);
  }

  function isPasswordField(el) {
    if (el instanceof HTMLInputElement) {
      if (el.type === 'password') return true;
      var name = (el.name || el.id || '').toLowerCase();
      if (name.includes('password') || name.includes('secret') || name.includes('token')) {
        return true;
      }
    }
    return false;
  }

  // ============================================================
  // EVENT HANDLERS
  // ============================================================

  function onClickCapture(e) {
    var target = e.target;
    if (!target || isOverlayElement(target)) return;
    captureEvent('click', target);
  }

  function onInputCapture(e) {
    var target = e.target;
    if (!target || isOverlayElement(target)) return;
    captureEvent('input', target, target.value);
  }

  function onChangeCapture(e) {
    var target = e.target;
    if (!target || isOverlayElement(target)) return;
    captureEvent('change', target, target.value);
  }

  function onSubmitCapture(e) {
    var target = e.target;
    if (!target) return;
    captureEvent('submit', target);
  }

  function onKeydownCapture(e) {
    // Only capture Enter, Tab, Escape, and keyboard shortcuts
    if (
      e.key === 'Enter' ||
      e.key === 'Tab' ||
      e.key === 'Escape' ||
      e.ctrlKey ||
      e.metaKey
    ) {
      var target = e.target;
      if (!target || isOverlayElement(target)) return;
      captureEvent('keydown', target, e.key);
    }
  }

  function isOverlayElement(el) {
    return el.closest('#mcpmaker-recording-indicator') !== null;
  }

  // ============================================================
  // VISIBILITY CHECK
  // ============================================================

  function isVisible(el) {
    var style = window.getComputedStyle(el);
    if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
      return false;
    }
    var rect = el.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0;
  }

  // ============================================================
  // ELEMENT FINDING (multi-strategy)
  // ============================================================

  function findElementByStrategies(req) {
    // Strategy 1: Exact selector
    if (req.selector) {
      try {
        var el = document.querySelector(req.selector);
        if (el && isVisible(el)) return el;
      } catch (e) {
        // Invalid selector
      }
    }

    // Strategy 2: Fallback selectors
    if (req.fallbackSelectors) {
      for (var i = 0; i < req.fallbackSelectors.length; i++) {
        try {
          var el2 = document.querySelector(req.fallbackSelectors[i]);
          if (el2 && isVisible(el2)) return el2;
        } catch (e) {
          // Invalid selector
        }
      }
    }

    // Strategy 3: aria-label matching
    if (req.ariaLabel) {
      try {
        var candidates = document.querySelectorAll('[aria-label="' + CSS.escape(req.ariaLabel) + '"]');
        for (var j = 0; j < candidates.length; j++) {
          if (isVisible(candidates[j])) return candidates[j];
        }
      } catch (e) {
        // Invalid selector
      }
    }

    // Strategy 4: Text content matching
    if (req.textContent) {
      var found = findByTextContent(req.textContent);
      if (found) return found;
    }

    return null;
  }

  function findByTextContent(text) {
    var normalized = text.trim().toLowerCase();
    var candidates = document.querySelectorAll(
      'button, a, [role="button"], [role="link"], label, span, p, h1, h2, h3, h4, h5, h6, td, th, li, div'
    );

    // Exact match first
    for (var i = 0; i < candidates.length; i++) {
      var elText = candidates[i].innerText ? candidates[i].innerText.trim().toLowerCase() : '';
      if (elText === normalized && isVisible(candidates[i])) return candidates[i];
    }

    // Starts-with match
    for (var j = 0; j < candidates.length; j++) {
      var elText2 = candidates[j].innerText ? candidates[j].innerText.trim().toLowerCase() : '';
      if (elText2 && elText2.startsWith(normalized) && isVisible(candidates[j])) return candidates[j];
    }

    // Contains match (only for shorter text)
    if (normalized.length >= 3) {
      for (var k = 0; k < candidates.length; k++) {
        var elText3 = candidates[k].innerText ? candidates[k].innerText.trim().toLowerCase() : '';
        if (elText3 && elText3.includes(normalized) && isVisible(candidates[k])) return candidates[k];
      }
    }

    return null;
  }

  // ============================================================
  // DOM ACTION EXECUTION (for playback)
  // ============================================================

  function executeDomAction(action) {
    var el = findElementByStrategies(action);

    if (!el) {
      return {
        success: false,
        error: 'Could not find the element on the page. The page may have changed since the workflow was recorded.'
      };
    }

    try {
      // Scroll element into view
      el.scrollIntoView({ behavior: 'smooth', block: 'center' });

      switch (action.type) {
        case 'click':
          el.click();
          break;

        case 'input':
          if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
            // Clear and set value via native input simulation (React/Vue bypass)
            var proto = el instanceof HTMLTextAreaElement
              ? HTMLTextAreaElement.prototype
              : HTMLInputElement.prototype;
            var nativeInputValueSetter = Object.getOwnPropertyDescriptor(proto, 'value');
            var setter = nativeInputValueSetter ? nativeInputValueSetter.set : null;

            if (setter) {
              setter.call(el, action.value || '');
            } else {
              el.value = action.value || '';
            }

            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
          } else if (el instanceof HTMLSelectElement) {
            el.value = action.value || '';
            el.dispatchEvent(new Event('change', { bubbles: true }));
          }
          break;

        case 'change':
          if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement) {
            el.value = action.value || '';
            el.dispatchEvent(new Event('change', { bubbles: true }));
          }
          break;

        case 'submit':
          var form = el instanceof HTMLFormElement ? el : el.closest('form');
          if (form) {
            form.dispatchEvent(new Event('submit', { bubbles: true }));
          }
          break;

        case 'keydown':
          var key = action.value || 'Enter';
          el.dispatchEvent(
            new KeyboardEvent('keydown', {
              key: key,
              bubbles: true,
              cancelable: true
            })
          );
          if (key === 'Enter') {
            el.dispatchEvent(
              new KeyboardEvent('keypress', {
                key: key,
                bubbles: true,
                cancelable: true
              })
            );
          }
          el.dispatchEvent(
            new KeyboardEvent('keyup', {
              key: key,
              bubbles: true,
              cancelable: true
            })
          );
          break;

        case 'navigate':
          if (action.value) {
            window.location.href = action.value;
          }
          break;

        default:
          return { success: false, error: 'Unknown action type: ' + action.type };
      }

      return { success: true };
    } catch (err) {
      return {
        success: false,
        error: 'Failed to perform the action: ' + (err && err.message ? err.message : String(err))
      };
    }
  }

  // ============================================================
  // PUBLIC: window.__mcpmaker_execute
  // Accepts a JSON string with action properties, returns JSON string with result
  // ============================================================

  window.__mcpmaker_execute = function (actionJSON) {
    try {
      var action = typeof actionJSON === 'string' ? JSON.parse(actionJSON) : actionJSON;
      var result = executeDomAction(action);
      return JSON.stringify(result);
    } catch (err) {
      return JSON.stringify({
        success: false,
        error: 'Failed to parse or execute action: ' + (err && err.message ? err.message : String(err))
      });
    }
  };

  // ============================================================
  // PUBLIC: window.__mcpmaker_snapshot
  // Returns a JSON string describing the current page state
  // ============================================================

  window.__mcpmaker_snapshot = function () {
    var snapshot = {
      url: window.location.href,
      title: document.title,
      interactiveElements: [],
      forms: [],
      headings: [],
      modals: []
    };

    // --- Interactive elements ---
    var interactiveSelectors = 'button, a, input, select, textarea, [role="button"], [role="link"], [role="menuitem"], [role="tab"], [role="checkbox"], [role="radio"], [role="switch"], [role="combobox"], [role="searchbox"], [role="textbox"], [contenteditable="true"]';
    var elements = document.querySelectorAll(interactiveSelectors);
    var idx = 0;

    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      if (!isVisible(el)) continue;

      var tagName = el.tagName.toLowerCase();
      var entry = {
        index: idx++,
        tag: tagName,
        type: el.getAttribute('type') || undefined,
        role: el.getAttribute('role') || undefined,
        ariaLabel: el.getAttribute('aria-label') || undefined,
        textContent: el.innerText ? el.innerText.trim().slice(0, 100) : undefined,
        placeholder: el.getAttribute('placeholder') || undefined,
        name: el.getAttribute('name') || undefined,
        selector: generateSelector(el),
        isDisabled: el.disabled === true || el.getAttribute('aria-disabled') === 'true'
      };

      // Include value for inputs/selects/textareas
      if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement) {
        var inputType = el instanceof HTMLInputElement ? el.type : tagName;
        if (inputType === 'password') {
          entry.value = '***SENSITIVE***';
        } else if (inputType !== 'file') {
          entry.value = el.value || undefined;
        }
      }

      // Clean up undefined fields
      var cleanEntry = {};
      for (var key in entry) {
        if (entry[key] !== undefined) {
          cleanEntry[key] = entry[key];
        }
      }

      snapshot.interactiveElements.push(cleanEntry);
    }

    // --- Forms ---
    var forms = document.querySelectorAll('form');
    for (var fi = 0; fi < forms.length; fi++) {
      var form = forms[fi];
      if (!isVisible(form)) continue;

      var formInfo = {
        selector: generateSelector(form),
        action: form.getAttribute('action') || undefined,
        method: form.getAttribute('method') || undefined,
        name: form.getAttribute('name') || undefined,
        fields: []
      };

      var fields = form.querySelectorAll('input, select, textarea');
      for (var fj = 0; fj < fields.length; fj++) {
        var field = fields[fj];
        var fieldTag = field.tagName.toLowerCase();
        var fieldInfo = {
          tag: fieldTag,
          type: field.getAttribute('type') || undefined,
          name: field.getAttribute('name') || undefined,
          placeholder: field.getAttribute('placeholder') || undefined,
          label: getAssociatedLabels(field).join(', ') || undefined,
          required: field.hasAttribute('required')
        };

        // Clean up undefined fields
        var cleanField = {};
        for (var fk in fieldInfo) {
          if (fieldInfo[fk] !== undefined) {
            cleanField[fk] = fieldInfo[fk];
          }
        }
        formInfo.fields.push(cleanField);
      }

      // Clean up undefined in formInfo
      var cleanForm = {};
      for (var fkey in formInfo) {
        if (formInfo[fkey] !== undefined) {
          cleanForm[fkey] = formInfo[fkey];
        }
      }
      snapshot.forms.push(cleanForm);
    }

    // --- Headings ---
    var headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    for (var hi = 0; hi < headings.length; hi++) {
      var heading = headings[hi];
      if (!isVisible(heading)) continue;
      var headingText = heading.innerText ? heading.innerText.trim() : '';
      if (headingText) {
        snapshot.headings.push({
          level: parseInt(heading.tagName.charAt(1), 10),
          text: headingText.slice(0, 200)
        });
      }
    }

    // --- Modal detection ---
    // Look for role="dialog", .modal, <dialog> elements
    var dialogSelectors = '[role="dialog"], [role="alertdialog"], .modal, .Modal, dialog';
    var dialogElements = document.querySelectorAll(dialogSelectors);
    for (var di = 0; di < dialogElements.length; di++) {
      var dialog = dialogElements[di];
      if (!isVisible(dialog)) continue;

      var modalTitle = '';
      // Try to find a heading inside the modal
      var modalHeading = dialog.querySelector('h1, h2, h3, h4, h5, h6, [role="heading"]');
      if (modalHeading && modalHeading.innerText) {
        modalTitle = modalHeading.innerText.trim().slice(0, 200);
      } else if (dialog.getAttribute('aria-label')) {
        modalTitle = dialog.getAttribute('aria-label');
      } else if (dialog.getAttribute('aria-labelledby')) {
        var titleEl = document.getElementById(dialog.getAttribute('aria-labelledby'));
        if (titleEl && titleEl.textContent) {
          modalTitle = titleEl.textContent.trim().slice(0, 200);
        }
      }

      snapshot.modals.push({
        selector: generateSelector(dialog),
        role: dialog.getAttribute('role') || dialog.tagName.toLowerCase(),
        title: modalTitle || undefined,
        isOpen: true
      });
    }

    return JSON.stringify(snapshot);
  };

  // ============================================================
  // MUTATION OBSERVER (URL change detection)
  // ============================================================

  function setupMutationObserver() {
    if (mutationObserver) return;

    var lastUrl = window.location.href;

    mutationObserver = new MutationObserver(function () {
      var currentUrl = window.location.href;
      if (currentUrl !== lastUrl) {
        lastUrl = currentUrl;
        if (window.__mcpmaker_recording) {
          captureEvent('navigate', document.body, currentUrl);
        }
      }
    });

    mutationObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  // ============================================================
  // RECORDING INDICATOR (Red Dot)
  // ============================================================

  function showRecordingIndicator() {
    if (recordingIndicator) return;

    recordingIndicator = document.createElement('div');
    recordingIndicator.id = 'mcpmaker-recording-indicator';
    recordingIndicator.innerHTML =
      '<style>' +
      '#mcpmaker-recording-indicator {' +
      '  position: fixed;' +
      '  top: 0.75rem;' +
      '  right: 0.75rem;' +
      '  z-index: 2147483647;' +
      '  display: flex;' +
      '  align-items: center;' +
      '  gap: 0.5rem;' +
      '  background: rgba(239, 68, 68, 0.95);' +
      '  color: white;' +
      '  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;' +
      '  font-size: 0.8125rem;' +
      '  font-weight: 500;' +
      '  padding: 0.5rem 0.875rem;' +
      '  border-radius: 1.25rem;' +
      '  box-shadow: 0 0.125rem 0.75rem rgba(0, 0, 0, 0.2);' +
      '  pointer-events: none;' +
      '  user-select: none;' +
      '}' +
      '#mcpmaker-recording-indicator .mcpmaker-dot {' +
      '  width: 0.625rem;' +
      '  height: 0.625rem;' +
      '  background: white;' +
      '  border-radius: 50%;' +
      '  animation: mcpmaker-pulse 1.5s ease-in-out infinite;' +
      '}' +
      '@keyframes mcpmaker-pulse {' +
      '  0%, 100% { opacity: 1; }' +
      '  50% { opacity: 0.3; }' +
      '}' +
      '</style>' +
      '<span class="mcpmaker-dot"></span>' +
      '<span>Recording</span>';
    document.body.appendChild(recordingIndicator);
  }

  function hideRecordingIndicator() {
    if (recordingIndicator) {
      recordingIndicator.remove();
      recordingIndicator = null;
    }
  }

  // ============================================================
  // HISTORY API PATCHING (catch SPA navigations)
  // ============================================================

  var originalPushState = history.pushState.bind(history);
  var originalReplaceState = history.replaceState.bind(history);

  history.pushState = function () {
    originalPushState.apply(history, arguments);
    if (window.__mcpmaker_recording) {
      captureEvent('navigate', document.body, window.location.href);
    }
  };

  history.replaceState = function () {
    originalReplaceState.apply(history, arguments);
    if (window.__mcpmaker_recording) {
      captureEvent('navigate', document.body, window.location.href);
    }
  };

  window.addEventListener('popstate', function () {
    if (window.__mcpmaker_recording) {
      captureEvent('navigate', document.body, window.location.href);
    }
  });

  // ============================================================
  // INITIALIZATION - Recording starts automatically
  // ============================================================

  document.addEventListener('click', onClickCapture, true);
  document.addEventListener('input', onInputCapture, true);
  document.addEventListener('change', onChangeCapture, true);
  document.addEventListener('submit', onSubmitCapture, true);
  document.addEventListener('keydown', onKeydownCapture, true);

  setupMutationObserver();
  showRecordingIndicator();

})();
