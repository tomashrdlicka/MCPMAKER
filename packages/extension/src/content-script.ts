// ============================================================
// MCPMAKER Content Script
// DOM event capture, mutation observation, and UI overlays
// ============================================================

// Ensure this file is treated as a module for TS compilation
export {};

// --- Inline Types ---

interface DOMEvent {
  timestamp: number;
  type: 'click' | 'input' | 'change' | 'submit' | 'navigate' | 'keydown';
  selector: string;
  elementContext: string;
  value?: string;
  windowId?: number;
  tabId?: number;
  inputType?: string;
  tagName?: string;
  attributes?: Record<string, string>;
  innerText?: string;
  ariaLabel?: string;
  formLabels?: string[];
  pageTitle?: string;
  pageUrl?: string;
}

// --- State ---

let isRecording = false;
let mutationObserver: MutationObserver | null = null;
let recordingIndicator: HTMLElement | null = null;
let playbackOverlay: HTMLElement | null = null;

// --- CSS Selector Generator ---

/**
 * Builds a robust, unique CSS selector for a given element.
 * Strategy:
 * 1. Try id-based selector
 * 2. Try data attributes (data-testid, data-cy, data-id)
 * 3. Try aria-label + role
 * 4. Build a full path from root
 */
function generateSelector(el: Element): string {
  // Strategy 1: ID
  if (el.id && !looksAutogenerated(el.id)) {
    const idSel = `#${CSS.escape(el.id)}`;
    if (isUnique(idSel)) return idSel;
  }

  // Strategy 2: Data attributes
  for (const attr of ['data-testid', 'data-cy', 'data-test', 'data-id']) {
    const val = el.getAttribute(attr);
    if (val) {
      const sel = `[${attr}="${CSS.escape(val)}"]`;
      if (isUnique(sel)) return sel;
    }
  }

  // Strategy 3: Aria-label + role
  const ariaLabel = el.getAttribute('aria-label');
  const role = el.getAttribute('role');
  if (ariaLabel) {
    const sel = role
      ? `[role="${CSS.escape(role)}"][aria-label="${CSS.escape(ariaLabel)}"]`
      : `[aria-label="${CSS.escape(ariaLabel)}"]`;
    if (isUnique(sel)) return sel;
  }

  // Strategy 4: Name attribute for form elements
  const name = el.getAttribute('name');
  if (name) {
    const tagName = el.tagName.toLowerCase();
    const sel = `${tagName}[name="${CSS.escape(name)}"]`;
    if (isUnique(sel)) return sel;
  }

  // Strategy 5: Build path from ancestors
  return buildPathSelector(el);
}

function looksAutogenerated(id: string): boolean {
  // IDs that look like random hashes or React-generated
  if (/^[a-f0-9]{8,}$/i.test(id)) return true;
  if (/^:r[0-9a-z]+:$/.test(id)) return true; // React auto IDs
  if (/^(ember|react|vue|ng|svelte)[_-]?\d+/i.test(id)) return true;
  if (id.length > 40) return true;
  return false;
}

function isUnique(selector: string): boolean {
  try {
    return document.querySelectorAll(selector).length === 1;
  } catch {
    return false;
  }
}

function buildPathSelector(el: Element): string {
  const parts: string[] = [];
  let current: Element | null = el;

  while (current && current !== document.documentElement) {
    let part = current.tagName.toLowerCase();

    // Add ID if available and not auto-generated
    if (current.id && !looksAutogenerated(current.id)) {
      parts.unshift(`#${CSS.escape(current.id)}`);
      break; // ID is a stable anchor
    }

    // Add class names (filter out dynamic/utility classes)
    const classes = getStableClasses(current);
    if (classes.length > 0) {
      part += '.' + classes.map(CSS.escape).join('.');
    }

    // Add nth-child if still not unique among siblings
    const parentEl: Element | null = current.parentElement;
    if (parentEl) {
      const currentTag = current.tagName;
      const siblings = Array.from(parentEl.children).filter(
        (s) => s.tagName === currentTag
      );
      if (siblings.length > 1) {
        const index = siblings.indexOf(current) + 1;
        part += `:nth-of-type(${index})`;
      }
    }

    parts.unshift(part);
    current = current.parentElement;

    // Stop if we have enough specificity (max depth 5)
    if (parts.length >= 5) break;
  }

  const selector = parts.join(' > ');

  // Verify the selector works
  try {
    if (document.querySelector(selector) === el) {
      return selector;
    }
  } catch {
    // Fall through to full path
  }

  // Fallback: full path with nth-child from body
  return buildFullPathSelector(el);
}

function buildFullPathSelector(el: Element): string {
  const parts: string[] = [];
  let current: Element | null = el;

  while (current && current !== document.body && current !== document.documentElement) {
    const parentEl: Element | null = current.parentElement;
    if (!parentEl) break;

    const index = Array.from(parentEl.children).indexOf(current) + 1;
    parts.unshift(`${current.tagName.toLowerCase()}:nth-child(${index})`);
    current = parentEl;
  }

  return 'body > ' + parts.join(' > ');
}

function getStableClasses(el: Element): string[] {
  const allClasses = Array.from(el.classList);
  return allClasses.filter((cls) => {
    // Filter out dynamic classes
    if (/^[a-z]{1,3}[A-Z]/.test(cls)) return false; // camelCase modules
    if (/^css-[a-z0-9]+$/i.test(cls)) return false; // CSS-in-JS
    if (/^_[a-zA-Z0-9]{5,}$/.test(cls)) return false; // Hashed
    if (/^sc-[a-zA-Z]/.test(cls)) return false; // styled-components
    if (/^[a-f0-9]{6,}$/i.test(cls)) return false; // Hash-like
    if (cls.includes('__') && cls.includes('--')) return true; // BEM is stable
    return true;
  }).slice(0, 3); // Max 3 classes for readability
}

// --- Element Context ---

function getElementContext(el: Element): string {
  const parts: string[] = [];
  const tagName = el.tagName.toLowerCase();
  parts.push(`<${tagName}>`);

  // Surrounding label text
  const labels = getAssociatedLabels(el);
  if (labels.length > 0) {
    parts.push(`labels: ${labels.join(', ')}`);
  }

  // Aria label
  const ariaLabel = el.getAttribute('aria-label');
  if (ariaLabel) {
    parts.push(`aria-label: "${ariaLabel}"`);
  }

  // Placeholder
  const placeholder = el.getAttribute('placeholder');
  if (placeholder) {
    parts.push(`placeholder: "${placeholder}"`);
  }

  // Button/link text
  const text = (el as HTMLElement).innerText?.trim();
  if (text && text.length < 100) {
    parts.push(`text: "${text.slice(0, 80)}"`);
  }

  // Title attribute
  const title = el.getAttribute('title');
  if (title) {
    parts.push(`title: "${title}"`);
  }

  return parts.join(' | ');
}

function getAssociatedLabels(el: Element): string[] {
  const labels: string[] = [];

  // Check for <label for="id"> association
  if (el.id) {
    const labelEl = document.querySelector(`label[for="${CSS.escape(el.id)}"]`);
    if (labelEl) {
      labels.push(labelEl.textContent?.trim() ?? '');
    }
  }

  // Check for parent <label>
  const parentLabel = el.closest('label');
  if (parentLabel) {
    const text = parentLabel.textContent?.trim();
    if (text) labels.push(text);
  }

  // Check for aria-labelledby
  const labelledBy = el.getAttribute('aria-labelledby');
  if (labelledBy) {
    const ids = labelledBy.split(/\s+/);
    for (const id of ids) {
      const labelEl = document.getElementById(id);
      if (labelEl) {
        labels.push(labelEl.textContent?.trim() ?? '');
      }
    }
  }

  return labels.filter(Boolean);
}

function getAttributes(el: Element): Record<string, string> {
  const attrs: Record<string, string> = {};
  const interestingAttrs = [
    'type', 'name', 'role', 'aria-label', 'aria-expanded',
    'aria-selected', 'aria-checked', 'href', 'src', 'action',
    'method', 'placeholder', 'data-testid', 'data-cy',
  ];
  for (const attr of interestingAttrs) {
    const val = el.getAttribute(attr);
    if (val !== null) {
      attrs[attr] = val;
    }
  }
  return attrs;
}

// --- Event Capture ---

function captureEvent(
  type: DOMEvent['type'],
  target: Element,
  value?: string
): void {
  if (!isRecording) return;

  const isSensitive = isPasswordField(target);

  const domEvent: DOMEvent = {
    timestamp: Date.now(),
    type,
    selector: generateSelector(target),
    elementContext: getElementContext(target),
    tagName: target.tagName.toLowerCase(),
    attributes: getAttributes(target),
    ariaLabel: target.getAttribute('aria-label') ?? undefined,
    innerText: (target as HTMLElement).innerText?.trim().slice(0, 200) ?? undefined,
    formLabels: getAssociatedLabels(target),
    pageTitle: document.title,
    pageUrl: window.location.href,
  };

  if (value !== undefined) {
    domEvent.value = isSensitive ? '***SENSITIVE***' : value;
  }

  if (isSensitive) {
    domEvent.inputType = 'password';
  } else if (target instanceof HTMLInputElement) {
    domEvent.inputType = target.type;
  }

  try {
    chrome.runtime.sendMessage({ type: 'DOM_EVENT', event: domEvent });
  } catch {
    // Extension context invalidated - stop recording
    stopRecordingCapture();
  }
}

function isPasswordField(el: Element): boolean {
  if (el instanceof HTMLInputElement) {
    if (el.type === 'password') return true;
    const name = (el.name || el.id || '').toLowerCase();
    if (name.includes('password') || name.includes('secret') || name.includes('token')) {
      return true;
    }
  }
  return false;
}

// --- Event Handlers ---

function onClickCapture(e: MouseEvent): void {
  const target = e.target as Element;
  if (!target || isOverlayElement(target)) return;
  captureEvent('click', target);
}

function onInputCapture(e: Event): void {
  const target = e.target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
  if (!target || isOverlayElement(target)) return;
  captureEvent('input', target, target.value);
}

function onChangeCapture(e: Event): void {
  const target = e.target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
  if (!target || isOverlayElement(target)) return;
  captureEvent('change', target, target.value);
}

function onSubmitCapture(e: Event): void {
  const target = e.target as Element;
  if (!target) return;
  captureEvent('submit', target);
}

function onKeydownCapture(e: KeyboardEvent): void {
  // Only capture Enter, Tab, Escape, and keyboard shortcuts
  if (
    e.key === 'Enter' ||
    e.key === 'Tab' ||
    e.key === 'Escape' ||
    e.ctrlKey ||
    e.metaKey
  ) {
    const target = e.target as Element;
    if (!target || isOverlayElement(target)) return;
    captureEvent('keydown', target, e.key);
  }
}

function isOverlayElement(el: Element): boolean {
  return el.closest('#mcpmaker-recording-indicator') !== null ||
    el.closest('#mcpmaker-playback-overlay') !== null;
}

// --- Mutation Observer ---

function setupMutationObserver(): void {
  if (mutationObserver) return;

  let lastUrl = window.location.href;

  mutationObserver = new MutationObserver(() => {
    const currentUrl = window.location.href;
    if (currentUrl !== lastUrl) {
      lastUrl = currentUrl;
      if (isRecording) {
        captureEvent('navigate', document.body, currentUrl);
      }
    }
  });

  mutationObserver.observe(document.body, {
    childList: true,
    subtree: true,
  });
}

function teardownMutationObserver(): void {
  if (mutationObserver) {
    mutationObserver.disconnect();
    mutationObserver = null;
  }
}

// --- Recording Control ---

function startRecordingCapture(): void {
  if (isRecording) return;
  isRecording = true;

  document.addEventListener('click', onClickCapture, true);
  document.addEventListener('input', onInputCapture, true);
  document.addEventListener('change', onChangeCapture, true);
  document.addEventListener('submit', onSubmitCapture, true);
  document.addEventListener('keydown', onKeydownCapture, true);

  setupMutationObserver();
  showRecordingIndicator();
}

function stopRecordingCapture(): void {
  if (!isRecording) return;
  isRecording = false;

  document.removeEventListener('click', onClickCapture, true);
  document.removeEventListener('input', onInputCapture, true);
  document.removeEventListener('change', onChangeCapture, true);
  document.removeEventListener('submit', onSubmitCapture, true);
  document.removeEventListener('keydown', onKeydownCapture, true);

  teardownMutationObserver();
  hideRecordingIndicator();
}

// --- Recording Indicator (Red Dot) ---

function showRecordingIndicator(): void {
  if (recordingIndicator) return;

  recordingIndicator = document.createElement('div');
  recordingIndicator.id = 'mcpmaker-recording-indicator';
  recordingIndicator.innerHTML = `
    <style>
      #mcpmaker-recording-indicator {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 2147483647;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(239, 68, 68, 0.95);
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 13px;
        font-weight: 500;
        padding: 8px 14px;
        border-radius: 20px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
        pointer-events: none;
        user-select: none;
      }
      #mcpmaker-recording-indicator .mcpmaker-dot {
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        animation: mcpmaker-pulse 1.5s ease-in-out infinite;
      }
      @keyframes mcpmaker-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
      }
    </style>
    <span class="mcpmaker-dot"></span>
    <span>Recording</span>
  `;
  document.body.appendChild(recordingIndicator);
}

function hideRecordingIndicator(): void {
  if (recordingIndicator) {
    recordingIndicator.remove();
    recordingIndicator = null;
  }
}

// --- Playback Overlay ---

function showPlaybackOverlay(steps: Array<{ description: string }>, currentStep: number, completedSteps: number[]): void {
  if (!playbackOverlay) {
    playbackOverlay = document.createElement('div');
    playbackOverlay.id = 'mcpmaker-playback-overlay';
    document.body.appendChild(playbackOverlay);
  }

  let stepsHtml = '';
  for (let i = 0; i < steps.length; i++) {
    let statusClass = 'mcpmaker-step-pending';
    let icon = `<span class="mcpmaker-step-num">${i + 1}</span>`;

    if (completedSteps.includes(i)) {
      statusClass = 'mcpmaker-step-complete';
      icon = '<span class="mcpmaker-step-check">&#10003;</span>';
    } else if (i === currentStep) {
      statusClass = 'mcpmaker-step-active';
      icon = '<span class="mcpmaker-step-spinner"></span>';
    }

    stepsHtml += `
      <div class="mcpmaker-step ${statusClass}">
        ${icon}
        <span class="mcpmaker-step-label">${escapeHtmlCS(steps[i].description)}</span>
      </div>
    `;
  }

  playbackOverlay.innerHTML = `
    <style>
      #mcpmaker-playback-overlay {
        position: fixed;
        bottom: 16px;
        right: 16px;
        z-index: 2147483647;
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid #e2e5ea;
        border-radius: 12px;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.12);
        padding: 16px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 13px;
        max-width: 300px;
        max-height: 400px;
        overflow-y: auto;
        user-select: none;
      }
      #mcpmaker-playback-overlay .mcpmaker-title {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 12px;
        color: #1a1d23;
      }
      #mcpmaker-playback-overlay .mcpmaker-step {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        color: #8e95a2;
      }
      #mcpmaker-playback-overlay .mcpmaker-step-active {
        color: #2563eb;
        font-weight: 500;
      }
      #mcpmaker-playback-overlay .mcpmaker-step-complete {
        color: #16a34a;
      }
      #mcpmaker-playback-overlay .mcpmaker-step-num {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: #f7f8fa;
        border: 1px solid #e2e5ea;
        font-size: 11px;
        flex-shrink: 0;
      }
      #mcpmaker-playback-overlay .mcpmaker-step-check {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: #f0fdf4;
        color: #16a34a;
        font-size: 12px;
        flex-shrink: 0;
      }
      #mcpmaker-playback-overlay .mcpmaker-step-spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #e2e5ea;
        border-top-color: #2563eb;
        border-radius: 50%;
        animation: mcpmaker-spin 0.8s linear infinite;
        flex-shrink: 0;
      }
      @keyframes mcpmaker-spin {
        to { transform: rotate(360deg); }
      }
      #mcpmaker-playback-overlay .mcpmaker-step-label {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
    </style>
    <div class="mcpmaker-title">Running workflow...</div>
    ${stepsHtml}
  `;
}

function hidePlaybackOverlay(): void {
  if (playbackOverlay) {
    playbackOverlay.remove();
    playbackOverlay = null;
  }
}

function escapeHtmlCS(str: string): string {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// --- Highlight Element (during playback) ---

function highlightElement(selector: string, duration: number = 800): void {
  try {
    const el = document.querySelector(selector);
    if (!el) return;

    const rect = el.getBoundingClientRect();
    const highlight = document.createElement('div');
    highlight.style.cssText = `
      position: fixed;
      top: ${rect.top - 3}px;
      left: ${rect.left - 3}px;
      width: ${rect.width + 6}px;
      height: ${rect.height + 6}px;
      border: 2px solid #2563eb;
      border-radius: 4px;
      background: rgba(37, 99, 235, 0.08);
      z-index: 2147483646;
      pointer-events: none;
      transition: opacity 0.3s;
    `;
    document.body.appendChild(highlight);

    setTimeout(() => {
      highlight.style.opacity = '0';
      setTimeout(() => highlight.remove(), 300);
    }, duration);
  } catch {
    // Element not found, ignore
  }
}

// --- Message Handler ---

chrome.runtime.onMessage.addListener(
  (
    message: Record<string, unknown>,
    _sender: chrome.runtime.MessageSender,
    sendResponse: (response?: unknown) => void
  ) => {
    switch (message.type) {
      case 'START_RECORDING_CONTENT':
        startRecordingCapture();
        sendResponse({ success: true });
        break;

      case 'STOP_RECORDING_CONTENT':
        stopRecordingCapture();
        sendResponse({ success: true });
        break;

      case 'HIGHLIGHT_ELEMENT':
        highlightElement(message.selector as string, (message.duration as number) ?? 800);
        sendResponse({ success: true });
        break;

      case 'SHOW_PLAYBACK_OVERLAY': {
        const steps = message.steps as Array<{ description: string }>;
        const currentStep = message.currentStep as number;
        const completedSteps = message.completedSteps as number[];
        showPlaybackOverlay(steps, currentStep, completedSteps);
        sendResponse({ success: true });
        break;
      }

      case 'HIDE_PLAYBACK_OVERLAY':
        hidePlaybackOverlay();
        sendResponse({ success: true });
        break;

      case 'EXECUTE_DOM_ACTION': {
        const result = executeDomAction(message.action as DomActionRequest);
        sendResponse(result);
        break;
      }

      case 'FIND_ELEMENT': {
        const found = findElementByStrategies(message as unknown as FindElementRequest);
        sendResponse({ found: !!found, selector: found ? generateSelector(found) : null });
        break;
      }

      default:
        sendResponse({ error: 'Unknown message type' });
    }
    return true; // Keep message channel open for async
  }
);

// --- DOM Action Execution (for playback) ---

interface DomActionRequest {
  type: string;
  selector: string;
  fallbackSelectors?: string[];
  ariaLabel?: string;
  textContent?: string;
  value?: string;
}

interface FindElementRequest {
  type: string;
  selector: string;
  fallbackSelectors?: string[];
  ariaLabel?: string;
  textContent?: string;
}

function findElementByStrategies(req: FindElementRequest): Element | null {
  // Strategy 1: Exact selector
  try {
    const el = document.querySelector(req.selector);
    if (el && isVisible(el)) return el;
  } catch {
    // Invalid selector
  }

  // Strategy 2: Fallback selectors
  if (req.fallbackSelectors) {
    for (const sel of req.fallbackSelectors) {
      try {
        const el = document.querySelector(sel);
        if (el && isVisible(el)) return el;
      } catch {
        // Invalid selector
      }
    }
  }

  // Strategy 3: aria-label + role matching
  if (req.ariaLabel) {
    const candidates = document.querySelectorAll(`[aria-label="${CSS.escape(req.ariaLabel)}"]`);
    for (const el of candidates) {
      if (isVisible(el)) return el;
    }
  }

  // Strategy 4: Text content matching
  if (req.textContent) {
    const el = findByTextContent(req.textContent);
    if (el) return el;
  }

  return null;
}

function findByTextContent(text: string): Element | null {
  const normalized = text.trim().toLowerCase();
  const candidates = document.querySelectorAll(
    'button, a, [role="button"], [role="link"], label, span, p, h1, h2, h3, h4, h5, h6, td, th, li, div'
  );

  // Exact match first
  for (const el of candidates) {
    const elText = (el as HTMLElement).innerText?.trim().toLowerCase();
    if (elText === normalized && isVisible(el)) return el;
  }

  // Starts-with match
  for (const el of candidates) {
    const elText = (el as HTMLElement).innerText?.trim().toLowerCase();
    if (elText?.startsWith(normalized) && isVisible(el)) return el;
  }

  // Contains match (only for shorter text)
  if (normalized.length >= 3) {
    for (const el of candidates) {
      const elText = (el as HTMLElement).innerText?.trim().toLowerCase();
      if (elText?.includes(normalized) && isVisible(el)) return el;
    }
  }

  return null;
}

function isVisible(el: Element): boolean {
  const style = window.getComputedStyle(el);
  if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
    return false;
  }
  const rect = el.getBoundingClientRect();
  return rect.width > 0 && rect.height > 0;
}

function executeDomAction(action: DomActionRequest): { success: boolean; error?: string } {
  const el = findElementByStrategies(action);

  if (!el) {
    return {
      success: false,
      error: `Could not find the element on the page. The page may have changed since the workflow was recorded.`,
    };
  }

  try {
    // Scroll element into view
    el.scrollIntoView({ behavior: 'smooth', block: 'center' });

    switch (action.type) {
      case 'click': {
        (el as HTMLElement).click();
        break;
      }

      case 'input': {
        if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
          // Clear and set value via native input simulation
          const nativeInputValueSetter =
            Object.getOwnPropertyDescriptor(
              el instanceof HTMLTextAreaElement
                ? HTMLTextAreaElement.prototype
                : HTMLInputElement.prototype,
              'value'
            )?.set;

          if (nativeInputValueSetter) {
            nativeInputValueSetter.call(el, action.value ?? '');
          } else {
            el.value = action.value ?? '';
          }

          el.dispatchEvent(new Event('input', { bubbles: true }));
          el.dispatchEvent(new Event('change', { bubbles: true }));
        } else if (el instanceof HTMLSelectElement) {
          el.value = action.value ?? '';
          el.dispatchEvent(new Event('change', { bubbles: true }));
        }
        break;
      }

      case 'change': {
        if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement) {
          el.value = action.value ?? '';
          el.dispatchEvent(new Event('change', { bubbles: true }));
        }
        break;
      }

      case 'submit': {
        const form = el instanceof HTMLFormElement ? el : el.closest('form');
        if (form) {
          form.dispatchEvent(new Event('submit', { bubbles: true }));
        }
        break;
      }

      case 'keydown': {
        const key = action.value ?? 'Enter';
        el.dispatchEvent(
          new KeyboardEvent('keydown', {
            key,
            bubbles: true,
            cancelable: true,
          })
        );
        if (key === 'Enter') {
          el.dispatchEvent(
            new KeyboardEvent('keypress', {
              key,
              bubbles: true,
              cancelable: true,
            })
          );
        }
        el.dispatchEvent(
          new KeyboardEvent('keyup', {
            key,
            bubbles: true,
            cancelable: true,
          })
        );
        break;
      }

      case 'navigate': {
        if (action.value) {
          window.location.href = action.value;
        }
        break;
      }

      default:
        return { success: false, error: `Unknown action type: ${action.type}` };
    }

    return { success: true };
  } catch (err) {
    return {
      success: false,
      error: `Failed to perform the action: ${err instanceof Error ? err.message : String(err)}`,
    };
  }
}

// --- Initialization ---

// Listen for page navigation via History API
const originalPushState = history.pushState.bind(history);
const originalReplaceState = history.replaceState.bind(history);

history.pushState = function (...args: Parameters<typeof history.pushState>) {
  originalPushState(...args);
  if (isRecording) {
    captureEvent('navigate', document.body, window.location.href);
  }
};

history.replaceState = function (...args: Parameters<typeof history.replaceState>) {
  originalReplaceState(...args);
  if (isRecording) {
    captureEvent('navigate', document.body, window.location.href);
  }
};

window.addEventListener('popstate', () => {
  if (isRecording) {
    captureEvent('navigate', document.body, window.location.href);
  }
});

// Check if we should be recording on load (in case of page navigation during recording)
chrome.runtime.sendMessage({ type: 'GET_RECORDING_STATUS' }, (response: { isRecording: boolean } | undefined) => {
  if (chrome.runtime.lastError) return;
  if (response && response.isRecording) {
    startRecordingCapture();
  }
});
